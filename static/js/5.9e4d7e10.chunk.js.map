{"version":3,"sources":["q/100.js"],"names":["className","data-index","dangerouslySetInnerHTML","__html"],"mappings":"qHAAe,qBACT,OACE,qBAAKA,UAAU,WAAWC,aAAW,MAAMC,wBAA2B,CAAEC,OAAO","file":"static/js/5.9e4d7e10.chunk.js","sourcesContent":["export default ()=> {\n      return (\n        <div className=\"question\" data-index=\"100\" dangerouslySetInnerHTML = {{ __html: `\n<h6>102. 依次输出什么?</h6>\n<pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword keyword-const\">const</span> <span class=\"token function-variable function\">myPromise</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I have resolved!'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword keyword-function\">function</span> <span class=\"token function\">firstFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">myPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'second'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword keyword-async\">async</span> <span class=\"token keyword keyword-function\">function</span> <span class=\"token function\">secondFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token keyword keyword-await\">await</span> <span class=\"token function\">myPromise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'second'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">firstFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n<span class=\"token function\">secondFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<ul>\n<li>A: <code>I have resolved!</code>, <code>second</code> and <code>I have resolved!</code>, <code>second</code></li>\n<li>B: <code>second</code>, <code>I have resolved!</code> and <code>second</code>, <code>I have resolved!</code></li>\n<li>C: <code>I have resolved!</code>, <code>second</code> and <code>second</code>, <code>I have resolved!</code></li>\n<li>D: <code>second</code>, <code>I have resolved!</code> and <code>I have resolved!</code>, <code>second</code></li>\n</ul>\n<details><summary><b>答案</b></summary>\n<p>\n<h4>答案: D</h4>\n<p>有了promise，我们通常会说：当我想要调用某个方法，但是由于它可能需要一段时间，因此暂时将它放在一边。只有当某个值被resolved/rejected，并且执行栈为空时才使用这个值。</p>\n<p>我们可以在<code>async</code>函数中通过<code>.then</code>和<code>await</code>关键字获得该值。 尽管我们可以通过<code>.then</code>和<code>await</code>获得promise的价值，但是它们的工作方式有所不同。</p>\n<p>在 <code>firstFunction</code>中，当运行到<code>myPromise</code>方法时我们将其放在一边，即promise进入微任务队列，其他后面的代码（<code>console.log('second')</code>）照常运行，因此<code>second</code>被打印出，<code>firstFunction</code>方法到此执行完毕，执行栈中宏任务队列被清空，此时开始执行微任务队列中的任务，<code>I have resolved</code>被打印出。</p>\n<p>在<code>secondFunction</code>方法中，我们通过<code>await</code>关键字，暂停了后面代码的执行，直到异步函数的值被解析才开始后面代码的执行。这意味着，它会等着直到 <code>myPromise</code> 以值<code>I have resolved</code>被解决之后，下一行<code>second</code>才开始执行。</p>\n</p>\n</details>\n` }}></div>\n      );\n    }"],"sourceRoot":""}